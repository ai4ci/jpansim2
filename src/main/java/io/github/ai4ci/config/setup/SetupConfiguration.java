package io.github.ai4ci.config.setup;

import java.io.Serializable;

import org.davidmoten.hilbert.HilbertCurve;
import org.davidmoten.hilbert.SmallHilbertCurve;
import org.immutables.value.Value;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

import io.github.ai4ci.abm.Abstraction;



/**
 * Configuration used during model setup and initialisation.
 *
 * <p>Main purpose: encapsulate the parameters and strategies required to
 * create agents and construct their contact network at the start of a
 * simulation. Features include:
 * <ul>
 *   <li>the number of initial imports used to seed an outbreak;</li>
 *   <li>a pluggable network generation strategy via {@link NetworkConfiguration};</li>
 *   <li>a pluggable demographic strategy via {@link DemographicConfiguration};</li>
 *   <li>utility methods for spatial placement such as {@link #hilbertBits()} and
 *       {@link #getHilbertCoords(Integer)}.</li>
 * </ul>
 *
 * <p>Downstream uses: instances are consulted by model builders and initialisers
 * during setup. Typical consumers include
 * {@link io.github.ai4ci.flow.builders.DefaultPersonInitialiser} and
 * {@link io.github.ai4ci.flow.builders.AbstractModelBuilder}. Implementations
 * are commonly generated by Immutables (see {@link ImmutableSetupConfiguration}).
 *
 * @author Rob Challen
 */
@Value.Immutable
@JsonSerialize(as = ImmutableSetupConfiguration.class)
@JsonDeserialize(as = ImmutableSetupConfiguration.class)
public interface SetupConfiguration extends Abstraction.Named, Abstraction.Replica, Serializable {

    /**
     * Default setup configuration used in examples and tests.
     */
    public ImmutableSetupConfiguration DEFAULT = ImmutableSetupConfiguration.builder()
            .setName("default")
            .setInitialImports(30)
            .setDemographics(LocationAwareDemography.DEFAULT)
            .setNetwork(ErdosReyniConfiguration.DEFAULT)
            .build();
    
    /**
     * Number of initial cases to seed the outbreak with.
     *
     * <p>Used by {@link io.github.ai4ci.flow.builders.DefaultPersonInitialiser} to
     * compute a simple per‑person importation probability during initialisation.
     * The value represents a coarse seeding strategy; for more sophisticated
     * seeding (geographically localised or stratified by demographic) supply
     * a custom initialiser in a composed {@link io.github.ai4ci.flow.builders.AbstractModelBuilder}.
     *
     * @return the number of initial imports to seed
     */
    Integer getInitialImports();

    /**
     * Network generation configuration.
     *
     * <p>The returned {@link NetworkConfiguration} defines which graph model is
     * used to construct the social network during the setup stage. The project
     * provides a few common implementations:
     * <ul>
     *   <li>{@link ErdosReyniConfiguration} — classical G(n,p) random graph;</li>
     *   <li>{@link WattsStrogatzConfiguration} — small‑world rewired lattice;</li>
     *   <li>{@link BarabasiAlbertConfiguration} — preferential attachment / scale free.</li>
     * </ul>
     *
     * <p>Builders call {@link NetworkConfiguration#generateGraph} passing an
     * empty JGraphT {@code SimpleGraph<Person,DefaultEdge>} to populate nodes
     * and edges. To add a new topology implement a new configuration type and
     * register it with the Jackson polymorphic mapping used by the config
     * loader.
     *
     * @return the network configuration used for agent placement and contact construction
     */
    NetworkConfiguration getNetwork();

    /**
     * Demographic configuration.
     *
     * <p>This selects the demographic strategy used when creating persons and
     * when computing pairwise relationship strengths. Common implementations
     * include:
     * <ul>
     *   <li>{@link UnstratifiedDemography} — draws strengths from a single distribution;</li>
     *   <li>{@link AgeStratifiedDemography} — samples ages and adjusts contact odds by age difference;</li>
     *   <li>{@link LocationAwareDemography} — supplies spatial placement and proximity based modifiers.</li>
     * </ul>
     *
     * <p>Demographic implementations are responsible for providing
     * {@link DemographicConfiguration#createPersonStub} used during setup and
     * {@link DemographicConfiguration#getRelationshipStrength} used when
     * composing contact probabilities. If you need richer per‑person data
     * (for example loading census CSVs) provide a custom Demographic
     * implementation and register it via Jackson polymorphism.
     *
     * @return the demographic configuration used during person creation and baselining
     */
    DemographicConfiguration getDemographics();
    
    
    @JsonIgnore
    default SmallHilbertCurve hilbertBits() {
        double size = (double) this.getNetwork().getNetworkSize();
        int bits = (int) Math.ceil(0.5*Math.log(size)/Math.log(2));
        return  HilbertCurve.small().bits(bits).dimensions(2);
    }
    
    /**
     * For sequentially created networks such as Watts‑Strogatz the
     * geographical location can be decided by the ring position. This will
     * tend to create a network that has geographical location correlating to
     * network topology.
     *
     * <p>The returned coordinates are normalised to the unit square [0,1]x[0,1]
     * and are suitable for assigning {@code locationX/locationY} on
     * {@link io.github.ai4ci.abm.PersonDemographic} during setup. The method
     * uses a Hilbert curve with bits chosen to provide adequate resolution
     * for the configured network size.
     *
     * @param id the ring position (for example the sequential node index)
     * @return an X‑Y geographical location (range 0 to 1)
     */
    @JsonIgnore
    default double[] getHilbertCoords(Integer id) {
        double size = (double) this.getNetwork().getNetworkSize();
        var hilbert = hilbertBits();
        long[] tmp =  hilbert.point((long) (id/size*Math.pow(2, hilbert.bits()*2)));
        return new double[] {
            ((double) tmp[0])/Math.pow(2, hilbert.bits()),
            ((double) tmp[1])/Math.pow(2, hilbert.bits()),
        };
    };
    
    
}
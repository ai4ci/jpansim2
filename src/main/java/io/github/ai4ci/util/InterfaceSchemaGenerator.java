package io.github.ai4ci.util;

import java.io.IOException;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import com.fasterxml.jackson.annotation.JsonProperty;

import io.github.ai4ci.Import;
// import io.github.classgraph.classloader.Handler;
import io.github.classgraph.ClassGraph;
import io.github.classgraph.ClassInfo;
import io.github.classgraph.ScanResult;

/**
 * Generates R interfacer::iface() specifications from all @Import-annotated
 * interfaces in a given Java package.
 *
 * Output is written to an R file.
 */
public class InterfaceSchemaGenerator {

    // Map Java types to R interfacer types
    private static final Map<Class<?>, String> TYPE_MAPPING = new HashMap<>();
    static {
        TYPE_MAPPING.put(String.class, "character");
        TYPE_MAPPING.put(Integer.class, "integer");
        TYPE_MAPPING.put(int.class, "integer");
        TYPE_MAPPING.put(Long.class, "double");
        TYPE_MAPPING.put(long.class, "double");
        TYPE_MAPPING.put(Double.class, "double");
        TYPE_MAPPING.put(double.class, "double");
        TYPE_MAPPING.put(Float.class, "numeric");
        TYPE_MAPPING.put(float.class, "numeric");
        TYPE_MAPPING.put(Boolean.class, "logical");
        TYPE_MAPPING.put(boolean.class, "logical");
        TYPE_MAPPING.put(Short.class, "integer");
        TYPE_MAPPING.put(short.class, "integer");
        TYPE_MAPPING.put(Byte.class, "integer");
        TYPE_MAPPING.put(byte.class, "integer");
    }

    public static void main(String[] args) {
        // === CONFIGURATION ===
        String packageName = args[0];  // Change this to your package
        String outputPath = args[1];                 // Output R file
        // =====================

        try {
            generateSchemas(packageName, Paths.get(outputPath));
            System.out.println("✅ Successfully generated R schemas at: " + outputPath);
        } catch (Exception e) {
            System.err.println("❌ Failed to generate schemas: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Scans the given package for @Import-annotated interfaces and generates R iface() code.
     * @throws SecurityException 
     * @throws NoSuchMethodException 
     */
    public static void generateSchemas(String packageName, Path outputPath) throws IOException, NoSuchMethodException, SecurityException {
        List<Class<?>> importClasses = scanForImportAnnotatedClasses(packageName);

        if (importClasses.isEmpty()) {
            throw new IllegalArgumentException("No @Import-annotated classes found in package: " + packageName);
        }

        // Build lookup map by simple name
        Map<String, Class<?>> classByName = importClasses.stream()
                .collect(Collectors.toMap(Class::getSimpleName, c -> c));

        // Generate R code
        List<String> rLines = new ArrayList<>();
        rLines.add("# Generated by InterfacerSchemaGenerator");
        rLines.add("# Do not edit manually\n");

        for (Class<?> cls : importClasses) {
            rLines.addAll(generateIfaceLines(cls, classByName));
            rLines.add(""); // blank line between defs
        }

        // Write to file
        Files.createDirectories(outputPath.getParent());
        try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(outputPath))) {
            rLines.forEach(out::println);
        }
    }

    private static List<String> generateIfaceLines(Class<?> cls, Map<String, Class<?>> classByName) throws NoSuchMethodException, SecurityException {
        List<String> lines = new ArrayList<>();
        String simpleName = cls.getSimpleName();
        String ifaceVarName = "i_" + simpleName.toLowerCase();

        lines.add("# maps to Java interface " + cls.getName());
        lines.add(simpleName.equals("Manifest") ? "# WARNING: Possible name conflict with java.util.jar.Manifest" : "");
        lines.add(simpleName.equals("Handler") ? "# WARNING: Possible name conflict with nonapi.io.github.classgraph.classloader.Handler" : "");

        lines.add(simpleName.equals("Manifest") || simpleName.equals("Handler") ?
                "# " + ifaceVarName + "_iface <- interfacer::iface(" :
                ifaceVarName + " <- interfacer::iface(");

        Method idMethod = findIdMethod(cls);
        Class<?> immClz = ReflectionUtils.immutable(cls);
		Class<?> builderClz = immClz.getMethod("builder").getReturnType();
		
        List<String> fieldLines = new ArrayList<>();

        for (Method method : builderClz.getMethods()) {
        	if (method.isAnnotationPresent(JsonProperty.class)) {

	            String fieldName = method.getAnnotation(JsonProperty.class).value();
	            Class<?> returnType = method.getParameterTypes()[0];
	
	            String rType;
	            String doc = "maps to java field " + simpleName + "." + method.getName();
	
	            // Foreign key: return type is another @Import-annotated interface
	            if (returnType.isAnnotationPresent(Import.class)) {
	                rType = "integer"; // FK becomes integer ID
	            } else {
	                rType = TYPE_MAPPING.getOrDefault(returnType, "character");
	            }
	
	            // Apply unique_id to ID field
	            // Matching setXXX in builder with getXXX in interface
	            if (
	            	method.getName().equals("s"+idMethod.getName().substring(1))
	            ) {
	                rType += " + unique_id";
	            }
	            
	            rType += " + not_missing";
	
	            fieldLines.add(String.format("  %s = %s ~ \"%s\"", fieldName, rType, doc));
        	}
        }

        // Join fields with comma
        if (!fieldLines.isEmpty()) {
            lines.add(String.join(",\n", fieldLines));
        }

        lines.add(")");

        // Filter out empty warnings
        return lines.stream().filter(s -> !s.trim().isEmpty() || s.contains("WARNING")).collect(Collectors.toList());
    }

    private static Method findIdMethod(Class<?> cls) {
        return Arrays.stream(cls.getMethods())
                .filter(m -> m.isAnnotationPresent(Import.Id.class))
                .findFirst()
                .orElse(null);
    }

    private static List<Class<?>> scanForImportAnnotatedClasses(String packageName) {
        try (ScanResult scanResult = new ClassGraph()
                .enableAllInfo()
                .acceptPackages(packageName)
                .scan()) {

            return scanResult.getClassesWithAnnotation(Import.class.getName())
                    .stream()
                    .filter(ClassInfo::isInterface)
                    .map(ClassInfo::loadClass)
                    .sorted(Comparator.comparing(Class::getSimpleName))
                    .collect(Collectors.toList());
        }
    }
}
package io.github.ai4ci.abm;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Optional;

import org.immutables.value.Value;

import io.github.ai4ci.config.ImmutableTestParameters;
import io.github.ai4ci.config.TestParameters;
import io.github.ai4ci.config.execution.ExecutionConfiguration;
import io.github.ai4ci.util.Sampler;
import io.github.ai4ci.util.ShallowList;

/**
 * Models a testing process and its outcome for an individual in the simulation.
 * This immutable value object captures the details of a single test event,
 * including the true viral load at the time of testing, the type of test
 * administered, and the observed result after accounting for test parameters
 * like sensitivity, specificity, and delay. Instances of this class are
 * typically generated by the simulation engine when a {@link Person} undergoes
 * testing. This class is {@link Serializable} for persistence across simulation
 * runs.
 */
@Value.Immutable
public interface TestResult extends Serializable {

	/**
	 * Defines the indication for which a test was performed.
	 * <ul>
	 * <li>{@code REACTIVE}: The test was performed in response to symptoms or
	 * known exposure.</li>
	 * <li>{@code SCREENING}: The test was performed as part of a routine
	 * screening program, without specific symptoms or known exposure.</li>
	 * </ul>
	 */
	public static enum Indication {
		/** The test was performed in response to symptoms or known exposure. */
		REACTIVE,
		/**
		 * The test was performed as part of a routine screening program, without
		 * specific symptoms or known exposure.
		 */
		SCREENING
	}

	/**
	 * Represents the possible outcomes of a test.
	 * <ul>
	 * <li>{@code PENDING}: The test has been taken but the result is not yet
	 * available due to processing delay.</li>
	 * <li>{@code POSITIVE}: The test result indicates the presence of the
	 * pathogen.</li>
	 * <li>{@code NEGATIVE}: The test result indicates the absence of the
	 * pathogen.</li>
	 * </ul>
	 */
	public enum Result {
		/**
		 * The test has been taken but the result is not yet available due to
		 * processing delay.
		 */
		PENDING,
		/** The test result indicates the presence of the pathogen. */
		POSITIVE,
		/** The test result indicates the absence of the pathogen. */
		NEGATIVE
	}

	/**
	 * Defines the types of tests available in the simulation, each with its
	 * specific parameters. These parameters, such as sensitivity, specificity,
	 * and test delay, are crucial for accurately modeling the diagnostic
	 * performance and logistical aspects of each test type. The viral load
	 * normalization described below is critical for interpreting these
	 * parameters.
	 */
	public static enum Type {
		/**
		 * A rapid antigen test with high sensitivity and specificity, and no
		 * delay.
		 */
		LFT(
				ImmutableTestParameters.builder().setSensitivity(0.9)
						.setSpecificity(0.98).setMeanTestDelay(0.0)
						.setSdTestDelay(0.0).setLimitOfDetection(1D)
		),
		/**
		 * A PCR test with slightly lower sensitivity but very high specificity,
		 * and a delay of a few days.
		 */
		PCR(
				ImmutableTestParameters.builder().setSensitivity(0.8)
						.setSpecificity(0.995).setMeanTestDelay(3.0)
						.setSdTestDelay(1.0).setLimitOfDetection(0.1)
		);

		private TestParameters params;

		private Type(ImmutableTestParameters.Builder params) {
			this.params = params.setTestName(this.name()).build();
		}

		/**
		 * Provides a builder initialized with the parameters of this test type,
		 * allowing for modification.
		 *
		 * @return An {@link ImmutableTestParameters.Builder} pre-filled with this
		 *         type's parameters.
		 */
		public ImmutableTestParameters.Builder modify() {
			return ImmutableTestParameters.builder().from(this.params);
		}

		/**
		 * Returns the {@link TestParameters} associated with this test type.
		 *
		 * @return The parameters defining the characteristics of this test type.
		 */
		public TestParameters params() {
			return this.params;
		}

	}

	private static TestResult build(
			double viralLoad, long time, TestParameters testParams,
			Indication indication
	) {
		return ImmutableTestResult.builder().setViralLoadTruth(viralLoad)
				.setTestParams(testParams).setIndication(indication).setTime(time)
				.build();
	}

	/**
	 * **Viral Load Normalization and Test Logic:** The viral load in the
	 * simulation is normalized such that a value of 1 represents a baseline
	 * infectious state that a perfectly sensitive and specific test
	 * {@code should} detect. This normalization is crucial for defining test
	 * sensitivity and specificity in a consistent manner.
	 *
	 * **Sensitivity and Specificity:** Test parameters ({@link TestParameters})
	 * define sensitivity and specificity. These are interpreted as follows:
	 * <ul>
	 * <li>**Sensitivity:** The probability that a test correctly identifies an
	 * infected individual (i.e., a true positive). In the model, this relates to
	 * the probability of detecting a viral load above the
	 * {@link TestParameters#getLimitOfDetection() limit of detection} given the
	 * true viral load is indicative of infection.</li>
	 * <li>**Specificity:** The probability that a test correctly identifies a
	 * non-infected individual (i.e., a true negative). This relates to the
	 * probability of a test returning negative when the true viral load is below
	 * the infectious threshold.</li>
	 * </ul>
	 * The {@link TestParameters#applyNoise(double, Sampler)} method is used to
	 * simulate the observed viral load sample, incorporating the inherent noise
	 * and limitations of the test, which in turn determines the
	 * {@link #getFinalObservedResult() final observed result}. The
	 * {@link TestParameters#getLimitOfDetection()} acts as the cutoff for
	 * determining a positive or negative observed result.
	 */

	/**
	 * Provides a {@link ShallowList} of default {@link TestParameters} for all
	 * defined {@link Type}s. This is useful for initializing the set of
	 * available tests in the simulation configuration.
	 *
	 * @return A {@link ShallowList} containing the default parameters for each
	 *         test type.
	 */
	static ShallowList<TestParameters> defaultTypes() {
		var tmp = new ShallowList<TestParameters>();
		Arrays.asList(Type.values()).stream().map(t -> t.params())
				.forEach(tmp::add);
		return tmp;
	}

	private static Optional<TestResult> resultFrom(
			ExecutionConfiguration cfg, double viralLoad, int time, String type,
			Indication indication
	) {

		return cfg.getAvailableTests().stream()
				.filter(tp -> tp.getTestName().equalsIgnoreCase(type)).findFirst()
				.map(params -> {
					return TestResult.build(
							viralLoad, // true test status as test is testing
											// infectiousness
							time, // test date
							params, indication
					);
				});
	}

	/**
	 * Creates an {@link Optional} {@link TestResult} for a given
	 * {@link PersonTemporalState} and {@link Type}. This factory method is used
	 * by the simulation to generate new test results. It retrieves the
	 * {@link ExecutionConfiguration} from the person's {@link Outbreak}, uses
	 * the person's {@link PersonTemporalState#getNormalisedViralLoad() current
	 * viral load} and {@link PersonTemporalState#getTime() current time}, and
	 * the specified {@link Type} to build a new {@link TestResult} with a
	 * {@link Indication#REACTIVE} indication.
	 *
	 * @param testee The {@link PersonTemporalState} of the individual being
	 *               tested.
	 * @param type   The {@link Type} of test to be performed.
	 * @return An {@link Optional} containing the new {@link TestResult}, or
	 *         empty if the test type is not found.
	 */
	public static Optional<TestResult> resultFrom(
			PersonTemporalState testee, Type type
	) {
		return resultFrom(
				testee.getEntity().getOutbreak().getExecutionConfiguration(),
				testee.getNormalisedViralLoad(), testee.getTime(), type.name(),
				Indication.REACTIVE
		);
	}

	/**
	 * Creates an {@link Optional} {@link TestResult} for a screening test,
	 * similar to {@link #resultFrom(PersonTemporalState, Type)}. This method
	 * specifically sets the {@link Indication} to {@link Indication#SCREENING}.
	 *
	 * @param testee The {@link PersonTemporalState} of the individual being
	 *               screened.
	 * @param type   The {@link Type} of screening test to be performed.
	 * @return An {@link Optional} containing the new screening
	 *         {@link TestResult}, or empty if the test type is not found.
	 */
	static Optional<TestResult> screeningResultFrom(
			PersonTemporalState testee, Type type
	) {
		return resultFrom(
				testee.getEntity().getOutbreak().getExecutionConfiguration(),
				testee.getNormalisedViralLoad(), testee.getTime(), type.name(),
				Indication.SCREENING
		);
	}

	/**
	 * Calculates the delay in days until the test result is available. This
	 * delay is sampled from a log-normal distribution using the mean and
	 * standard deviation specified in {@link TestParameters#getMeanTestDelay()}
	 * and {@link TestParameters#getSdTestDelay()}. A {@link Sampler} is used to
	 * introduce stochasticity in the delay.
	 *
	 * @return The test delay in days as a long.
	 */
	@Value.Derived
	public default long getDelay() {
		var rng = Sampler.getSampler();
		return Math.round(
				rng.logNormal(
						this.getTestParams().getMeanTestDelay(),
						this.getTestParams().getSdTestDelay()
				)
		);
	}

	/**
	 * Determines the final observed result of the test based on the
	 * {@link #getViralLoadSample() sampled viral load} and the
	 * {@link TestParameters#getLimitOfDetection() test's limit of detection}. If
	 * the sampled viral load is greater than the limit of detection, the result
	 * is considered positive.
	 *
	 * @return {@code true} if the final observed result is positive,
	 *         {@code false} otherwise.
	 */
	@Value.Derived
	default public boolean getFinalObservedResult() {
		return (this.getViralLoadSample() > this.getTestParams()
				.getLimitOfDetection());
	}

	/**
	 * Returns the final {@link Result} of the test (either
	 * {@link Result#POSITIVE} or {@link Result#NEGATIVE}). This is directly
	 * derived from {@link #getFinalObservedResult()}.
	 *
	 * @return The final {@link Result} of the test.
	 */
	default public Result getFinalResult() {
		if (this.getFinalObservedResult()) { return Result.POSITIVE; }
		return Result.NEGATIVE;
	}

	/**
	 * Returns the {@link Indication} for which this test was performed (e.g.,
	 * REACTIVE or SCREENING).
	 *
	 * @return The {@link Indication} of the test.
	 */
	public Indication getIndication();

	/**
	 * Calculates the estimated time (day) when the test result will become
	 * available. This is determined by adding the {@link #getDelay() test delay}
	 * to the {@link #getTime() sampling time}.
	 *
	 * @return The estimated result availability time as a long.
	 */
	default long getResultTime() { return this.getTime() + this.getDelay(); }

	/**
	 * Returns the {@link TestParameters} that define the characteristics of this
	 * specific test. These parameters include sensitivity, specificity, and
	 * delay, which influence the observed test result.
	 *
	 * @return The {@link TestParameters} for this test.
	 */
	public TestParameters getTestParams();

	/**
	 * Returns the simulation time (day) when the test was sampled.
	 *
	 * @return The time of test sampling as a long.
	 */
	public long getTime();

//	default public boolean confirmedPositive(int day) {
//		return (resultOnDay(day) == Result.POSITIVE);
//	}
//
//	default public boolean confirmedNegative(int day) {
//		return (resultOnDay(day) == Result.NEGATIVE);
//	}

//	@Value.Derived default public Result getTrueResult() {
//		if (getViralLoadTruth() > 1) return Result.POSITIVE;
//		return Result.NEGATIVE;
//	}

	/**
	 * Calculates and returns the observed viral load sample, which incorporates
	 * noise based on the test's characteristics. This value is derived from
	 * {@link #getViralLoadTruth()} by applying a noise model defined in
	 * {@link TestParameters#applyNoise(double, Sampler)}. The noise simulates
	 * the variability and imperfections of real-world testing.
	 *
	 * @return The sampled viral load as a double.
	 */
	@Value.Derived
	public default double getViralLoadSample() {
		var rng = Sampler.getSampler();
		return this.getTestParams().applyNoise(this.getViralLoadTruth(), rng);
	}

	/**
	 * Returns the true viral load of the person at the time the test was
	 * sampled. This value represents the actual biological state, independent of
	 * test performance.
	 *
	 * @return The true viral load as a double.
	 */
	public double getViralLoadTruth();

//	// what is the probability given a particular result that the person
//	// has disease?
//	// If the disease is uncommon the positive test is still less likely
//	// to be due to disease.
//	default double postTestProbPositive(int day, double prevalence) {
//		if (resultOnDay(day).equals(Result.POSITIVE)) {
//			return this.getTestParams().postPositiveTestProbability(prevalence);
//		} else if (resultOnDay(day).equals(Result.NEGATIVE)) {
//			return this.getTestParams().postNegativeTestProbability(prevalence);
//		} else {
//			return prevalence;
//		}
//	}
//
//	default double postTestProbNegative(int day, double prevalence) {
//		return 1-postTestProbPositive(day, prevalence);
//	}

	/**
	 * Checks if the test result is available by the specified {@code day}. This
	 * is true if the {@code day} is greater than or equal to the
	 * {@link #getResultTime() result availability time}.
	 *
	 * @param day The current simulation day to check against.
	 * @return {@code true} if the result is available by this day, {@code false}
	 *         otherwise.
	 */
	default public boolean isResultAvailable(int day) {
		return day >= this.getTime() + this.getDelay();
	}

	/**
	 * Checks if the test result is considered current on a given {@code day}
	 * within a {@code recoveryTime} window. A result is current if the
	 * {@code day} is on or after the {@link #getTime() test sampling time} and
	 * before {@code getTime() + recoveryTime}.
	 *
	 * @param day          The current simulation day.
	 * @param recoveryTime The duration for which the test result remains
	 *                     relevant.
	 * @return {@code true} if the result is current, {@code false} otherwise.
	 */
	default public boolean isResultCurrent(long day, long recoveryTime) {
		return day >= this.getTime() && day < this.getTime() + recoveryTime;
	}

	/**
	 * Checks if the test result becomes available on the specified {@code day}.
	 * This is true if the {@code day} matches the {@link #getResultTime() result
	 * availability time}.
	 *
	 * @param day The current simulation day to check against.
	 * @return {@code true} if the result is available today, {@code false}
	 *         otherwise.
	 */
	default public boolean isResultToday(int day) {
		return day == this.getTime() + this.getDelay();
	}

	/**
	 * The log likelihood ratio {@code delay} days after the test was taken. If
	 * the actual {@link #getDelay() test delay} is greater than the provided
	 * {@code delay}, a value of 0 is returned, meaning the result is not yet
	 * available at that point. Otherwise, {@link #trueLogLikelihoodRatio()} is
	 * returned.
	 *
	 * @param delay The number of days after the test was taken.
	 * @return The log-likelihood ratio at the specified delay.
	 */
	default double logLikelihoodRatio(int delay) {
		if (this.getDelay() > delay) { return 0; }
		return this.trueLogLikelihoodRatio();
	}

//	default public Optional<Result> publishedResult(int day) {
//		if (day != getTime()+getDelay()) return Optional.empty();
//		return Optional.of(this.resultOnDay(day));
//	}

	/**
	 * Returns the log-likelihood ratio for the test result, considering its
	 * relevance within a specified time window. If the result is considered
	 * current (i.e., {@link #isResultCurrent(long, long)} returns true for the
	 * given day and recovery time), then {@link #trueLogLikelihoodRatio()} is
	 * returned. Otherwise, a value of 0 is returned, indicating no current
	 * evidential impact.
	 *
	 * @param day   The current simulation day.
	 * @param limit The recovery time or duration for which the test result
	 *              remains current.
	 * @return The log-likelihood ratio for the specified day and limit.
	 */
	default double logLikelihoodRatio(int day, int limit) {
		if (this.isResultCurrent(day, limit)) {
			return this.trueLogLikelihoodRatio();
		}
		return 0;
	}

	/**
	 * Returns the {@link Result} of the test on a given {@code day}. If the
	 * result is not yet available ({@link #isResultAvailable(int)} is false), it
	 * returns {@link Result#PENDING}. Otherwise, it returns
	 * {@link Result#POSITIVE} or {@link Result#NEGATIVE} based on
	 * {@link #getFinalObservedResult()}.
	 *
	 * @param day The current simulation day.
	 * @return The {@link Result} of the test for the specified day.
	 */
	default public Result resultOnDay(int day) {
		if (!this.isResultAvailable(day)) { return Result.PENDING; }
		if (this.getFinalObservedResult()) { return Result.POSITIVE; }
		return Result.NEGATIVE;
	}

	/**
	 * Calculates the true log-likelihood ratio for this test result. This ratio
	 * quantifies the change in the odds of infection given the observed test
	 * result. It is calculated based on whether the
	 * {@link #getFinalObservedResult() final observed result} is positive or
	 * negative, using {@link TestParameters#positiveLikelihoodRatio()} or
	 * {@link TestParameters#negativeLikelihoodRatio()}.
	 *
	 * @return The true log-likelihood ratio as a double.
	 */
	@Value.Derived
	default double trueLogLikelihoodRatio() {
		return this.getFinalObservedResult()
				? Math.log(this.getTestParams().positiveLikelihoodRatio())
				: Math.log(this.getTestParams().negativeLikelihoodRatio());
	}

}
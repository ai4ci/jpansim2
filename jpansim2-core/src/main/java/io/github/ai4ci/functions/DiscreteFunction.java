package io.github.ai4ci.functions;

import java.io.Serializable;

import org.immutables.value.Value;
import org.mariuszgromada.math.mxparser.Argument;
import org.mariuszgromada.math.mxparser.Expression;
import org.mariuszgromada.math.mxparser.mXparser;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

/**
 * A discrete mathematical function defined by a univariate expression.
 *
 * <p>
 * This interface represents a discrete function that can be evaluated at
 * integer time points. The function is defined by a univariate mathematical
 * expression provided as a string, where the variable `t` represents time. The
 * expression is parsed and evaluated using the mXparser library.
 *
 * <p>
 * Downstream uses include any context where a time‑dependent function is
 * needed, such as in‑host models or demographic adjustments. Implementations
 * are commonly generated by Immutables (see {@link ImmutableDiscreteFunction}).
 *
 * @author Rob Challen
 */
@Value.Immutable
@JsonSerialize(as = ImmutableDiscreteFunction.class)
@JsonDeserialize(as = ImmutableDiscreteFunction.class)
public interface DiscreteFunction extends Serializable, KernelFunction {

	// NB this probably needs a lot of refactoring.
	// The discrete function should not really be a Kernel function but a
	// Way of specifying one. The normalisation that happens in
	// KernelFunction.values()
	// Does not make particular sense given the traditional meaning of a kernel
	// function. The output of KernelFunction is strictly enforced between 0 and
	// 1
	// which this is not... So I think all sorts of mistakes could happen here.
	// There is a question about how these are applied to the components of the
	// RiskModel in update() and whether actually it is appropriate this is a
	// 0..1 range or ought to be on the logistic scale. The whole thing needs
	// some hard core testing

	// On the plus side this caches its values already due to the @Value.Derived
	// annotation of KernelFunction so should be relatively performant.

	/**
	 * A univariate mathematical function as a String containing `t` as the
	 * parameter. Supported expressions are described here:
	 * https://mathparser.org/mxparser-math-collection.
	 *
	 * @return the function expression.
	 */
	String getFTExpression();

	/**
	 * The parsed expression is derived from the function expression and the time
	 * argument. It is not intended to be set directly and is ignored during JSON
	 * serialization.
	 *
	 * @return the parsed expression derived from the function expression and the
	 *         time argument.
	 */
	@JsonIgnore @Value.Derived
	default Expression getParsed() {
		mXparser.disableUlpRounding();
		mXparser.disableCanonicalRounding();
		mXparser.disableAlmostIntRounding();
		var t = this.getTimeArgument();
		return new Expression(this.getFTExpression(), t);
	}

	/**
	 * The following methods are derived from the function expression and are not
	 * intended to be set directly. They are ignored during JSON serialization.
	 *
	 * @return the time argument and the parsed expression derived from the
	 *         function expression.
	 */
	@JsonIgnore @Value.Derived
	default Argument getTimeArgument() { return new Argument("t"); }

	/**
	 * Evaluate the function at a given integer time `t`. This method sets the
	 * value of the time argument and then calculates the result using the parsed
	 * expression.
	 *
	 * @param t the time at which to evaluate the function.
	 * @return the result of evaluating the function at time `t`.
	 * @throws IllegalArgumentException if the function expression is invalid or
	 *                                  if evaluation fails.
	 * @see #getFTExpression()
	 *
	 */
	@Override
	default double rawValue(int t) {
		var xArg = this.getTimeArgument();
		xArg.setArgumentValue(t);
		var result = this.getParsed()
			.calculate();
		return result;
	}

}

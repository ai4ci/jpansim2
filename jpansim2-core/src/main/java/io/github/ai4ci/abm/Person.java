package io.github.ai4ci.abm;

import java.util.List;
import java.util.Optional;

import org.immutables.value.Value;

import io.github.ai4ci.Data;
import io.github.ai4ci.abm.Abstraction.Entity;
import io.github.ai4ci.abm.Abstraction.HistoricalStateProvider;
import io.github.ai4ci.flow.mechanics.StateMachine;
import io.github.ai4ci.util.Ephemeral;

/**
 * The main Person class is a mutable holder that contains immutable data
 * pertaining to baseline, current state, recent history etc.
 * <p>
 * Implementations are generated by Immutables and are used throughout the
 * simulation to represent individuals, their baseline metadata, and transient
 * state during an update cycle.
 */
@Value.Modifiable
@Data.Mutable
public abstract class Person
		implements Entity, HistoricalStateProvider<PersonHistory> {

	/**
	 * Creates a new person and adds them into the outbreak network. The created
	 * person is a minimal "stub" instance: it will be assigned an id and
	 * outbreak reference; other fields will be initialised with sensible empty
	 * values so that the instance can be safely used during network
	 * construction.
	 *
	 * @param outbreak the outbreak instance this person will belong to
	 * @return a modifiable person stub attached to the provided outbreak
	 */
	public static ModifiablePerson createPersonStub(Outbreak outbreak) {
		var tmp = new ModifiablePerson();
		tmp.setOutbreak(outbreak);
		var id = outbreak.getPeople().put(tmp);
		tmp.setId(id);
		tmp.setNextHistory(Ephemeral.empty());
		tmp.setNextState(Ephemeral.empty());
		tmp.setStateMachine(StateMachine.stub());
		tmp.setDemographic(PersonDemographic.stub(tmp));
		return tmp;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public final boolean equals(Object another) {
		return super.equals(another);
	}

	/**
	 * Immutable baseline information for this person (e.g. comorbidities,
	 * baseline behaviours). This is stable for the duration of a simulation run.
	 *
	 * @return the {@link PersonBaseline} for this person
	 */
	public abstract PersonBaseline getBaseline();

	/**
	 * Gets the first history item unless there is no history. If called during
	 * update cycle this will get the history at the same time as the current
	 * state. If called after it will be the previous day.
	 *
	 * @return an {@link Optional} containing the most recent
	 *         {@link PersonHistory} or {@link Optional#empty()} if no history
	 *         exists
	 */
	public Optional<PersonHistory> getCurrentHistory() {
		if (this.getHistory().size() == 0) { return Optional.empty(); }
		return Optional.of(this.getHistory().get(0));
	}

	/**
	 * The current immutable state of the person for the current simulation
	 * timestep. This represents the snapshot of their epidemiological and
	 * behavioural state used for computing transitions.
	 *
	 * @return the current {@link PersonState}
	 */
	public abstract PersonState getCurrentState();

	/**
	 * Demographic information for the person such as age group and other
	 * population-level stratifiers used in the simulation.
	 *
	 * @return the {@link PersonDemographic} instance
	 */
	public abstract PersonDemographic getDemographic();

	/**
	 * Reverse time ordered list of historical states (recent first).
	 *
	 * @return list of {@link PersonHistory} entries in reverse chronological
	 *         order
	 */
	@Override
	public abstract List<PersonHistory> getHistory();

	/**
	 * The unique numeric identifier for this person within the outbreak network.
	 *
	 * @return person's id (non-null)
	 */
	public abstract Integer getId();

	/**
	 * Only populated during the update cycle largely as a mapping from the t-1
	 * state. Historical events are added most notably test sampling.
	 *
	 * @return ephemeral builder for next person history
	 */
	public abstract Ephemeral<ImmutablePersonHistory.Builder> getNextHistory();

	/**
	 * Only populated during the update cycle, and copied from the t-1 state.
	 * This is where changes to the future t state are made.
	 *
	 * @return ephemeral builder for next person state
	 */
	public abstract Ephemeral<ImmutablePersonState.Builder> getNextState();

	/**
	 * The outbreak this person belongs to. Never null for a created person.
	 *
	 * @return the associated {@link Outbreak}
	 */
	public abstract Outbreak getOutbreak();

	/**
	 * The person's behavioural state machine.
	 *
	 * @return the person's {@link StateMachine} for behaviour transitions
	 */
	public abstract StateMachine getStateMachine();

	/**
	 * Returns a persistent unique resource name for this person within the
	 * outbreak, used primarily for logging and diagnostics.
	 *
	 * @return URN string in the form {@code <outbreak-urn>:person:<id>}
	 */
	@Override
	public String getUrn() {
		return this.getOutbreak().getUrn() + ":person:" + this.getId();
	}

	/**
	 * {@inheritDoc}
	 *
	 * Implementations delegate equality and hashing to object identity for
	 * mutable persons: these methods are final to prevent accidental
	 * redefinition in generated classes.
	 */
	@Override
	public final int hashCode() {
		return super.hashCode();
	}

	/**
	 * Returns the URN for this person. This provides a human-friendly
	 * representation useful for logging.
	 */
	@Override
	public String toString() {
		return this.getUrn();
	}
}